# Советы по CI/CD для `parse-ledger`

Ниже — практичные рекомендации, чтобы деплои были предсказуемыми, быстрыми и безопасными (с учётом текущей архитектуры: Dockerfile в корне, Railway deploy, frontend+backend в одном сервисе, Postgres/Redis отдельно).

## 1) Стратегия деплоя и окружения

- **Раздели окружения**: `production` и `staging` как минимум (в Railway — отдельные environments или отдельные проекты).
- **Деплой по веткам**: `main` → production, `develop`/`staging` → staging.
- **Promote вместо “пересборки”**: если Railway позволяет, продвигай уже собранный артефакт из staging в production (уменьшает риск “собралось по‑другому”).

## 2) Миграции БД как часть CD

- Держи правило: **код и миграции деплоятся вместе**.
- В проекте уже включён авто‑запуск миграций при старте контейнера (`scripts/start.sh`). Это устраняет ручные шаги и снижает вероятность рассинхронизации схемы.
- Если планируешь несколько реплик — добавь защиту от параллельного запуска миграций (advisory lock в Postgres или отдельный one-off job).

## 3) Проверки (CI) перед деплоем

Минимальный набор, который стоит запускать на PR/пуш:

- **Линт**: `npm --prefix backend run lint` (и аналогично для frontend, если настроено).
- **Тесты**: `npm --prefix backend test` (плюс frontend-тесты, если появятся).
- **Сборка**: `npm --prefix backend run build` и `npm --prefix frontend run build` (или единая сборка через Docker).

Рекомендация: если основная “истина” — Dockerfile, то **в CI собирай Docker-образ**, чтобы ловить проблемы как на Railway.

## 4) Быстрота сборок и кэш

- В Dockerfile уже корректно вынесены `package*.json` отдельно — это улучшает кэш.
- Следи, чтобы изменения не ломали кеширование (например, не копировать весь репозиторий до `npm ci`).
- По возможности используй **lockfiles** (`package-lock.json`) как обязательные: сборка должна быть воспроизводимой.

## 5) Секреты и конфигурация

- Никогда не коммить секреты: `.env` локально, в Railway — environment variables.
- Не храни в репо `DATABASE_URL` для проды; пусть Railway управляет подключением к Postgres.
- Добавь “обязательные” переменные в документацию/чеклист (JWT секреты и т.д.) и/или проверку при старте (fail-fast).

## 6) Надёжный старт и healthchecks

- Деплой должен считаться успешным только если проходит healthcheck.
- Убедись, что эндпоинт `/api/v1/health`:
  - не зависит от внешних API,
  - быстро отвечает,
  - по возможности проверяет подключение к базе (или имей отдельный `readiness`).

## 7) Наблюдаемость и алерты

- Логи: структурированные (уровни, request id, user/workspace id где уместно).
- Метрики: минимум — latency/ошибки по API, количество задач/джоб, ошибки миграций.
- Алертинг: деплой упал, healthcheck не проходит, рост 5xx, проблемы с базой/redis.

## 8) Git практики, которые помогают CI/CD

- PR обязателен в `main` (код‑ревью + CI статусы).
- Маленькие PR: легче откатить, легче расследовать.
- Conventional commits или хотя бы единый формат сообщений — удобнее для релиз‑нотов.

## 9) Откат (rollback) и обратимые изменения

- Думай “в 2 шага” для рискованных изменений схемы:
  1) добавить новые поля/таблицы (совместимо со старым кодом),
  2) переключить код,
  3) позже удалить старое (если нужно).
- Для проды избегай миграций, которые держат долгие блокировки (например, массовые `ALTER TABLE` без планирования).

## 10) Что добавить дальше (по желанию)

- GitHub Actions workflow: lint + тесты + сборка Docker на PR.
- Автогенерация release notes по тегам.
- Авто-деплой в staging на каждый PR (preview environment), если это подходит по стоимости/процессу.

