# Автоприменение миграций на Railway при деплое (CI/CD)

Цель: после `git push` Railway собирает и деплоит сервис, а перед стартом приложения автоматически находит и применяет новые миграции TypeORM — без ручного `railway exec ... migration:run`.

## Предпосылки

- Бэкенд использует TypeORM и миграции (в этом репозитории: `backend/src/migrations`).
- Деплой идёт через Dockerfile, а старт контейнера — через `./scripts/start.sh` (см. `railway.json`).
- Переменная `DATABASE_URL` настроена в Railway (PostgreSQL сервис подключён).

## Рекомендуемый вариант: миграции запускаются при старте контейнера

Идея: перед поднятием бэкенда выполнить команду, которая применит **только новые** миграции (TypeORM хранит прогресс в таблице `migrations`).

### 1) Добавь шаг запуска миграций в `scripts/start.sh`

В проекте это уже реализовано: `scripts/start.sh` запускает миграции **до** старта бэкенда, и делает это безопасно для нескольких реплик через Postgres advisory lock.

```sh
echo "Running DB migrations..."
node backend/scripts/run-migrations-with-lock.js
echo "DB migrations done"
```

Примерная логика по порядку:
1) `backend/scripts/run-migrations-with-lock.js` (advisory lock + retry)
2) старт бэкенда
3) старт фронтенда

### 2) Настройки (опционально)

Скрипт поддерживает переменные окружения (можно задать в Railway):

- `MIGRATIONS_LOCK_KEY_1` / `MIGRATIONS_LOCK_KEY_2` — ключ advisory lock (int,int), по умолчанию `240517` и `1`.
- `MIGRATIONS_RETRY_ATTEMPTS` — сколько попыток при старте (по умолчанию `10`).
- `MIGRATIONS_RETRY_DELAY_MS` — пауза между попытками (по умолчанию `2000`).

### 3) Закоммить и запушь изменения

После `git push` Railway автоматически сделает новый деплой; на старте контейнера миграции будут применяться автоматически.

### 3) Проверь в логах Railway

В логах деплоя/рантайма должны появиться строки про `Running migrations...` и успешное завершение.

## Важные моменты (чтобы не словить проблемы в проде)

### Миграции должны быть идемпотентными и “forward-only”

- Не используй `synchronize: true` в проде (в этом проекте `synchronize: false` уже выставлено).
- Миграции должны корректно выполняться на базе в любом промежуточном состоянии (с учётом уже применённых миграций).

### Что если запущено несколько реплик приложения

Если сервис масштабирован в несколько инстансов, при одновременном старте есть риск конкурентного запуска миграций.

Рекомендации:
- Запускать миграции только в одном экземпляре (обычно Railway по умолчанию запускает 1 инстанс).
- Если планируется горизонтальное масштабирование — добавь механизм блокировки (например, advisory lock в Postgres) вокруг запуска миграций, либо вынеси миграции в отдельный “one-off” шаг/джобу.

### Что делать, если миграции упали

- Контейнер не должен “молча” продолжать старт: пусть деплой падает, чтобы проблема была видна сразу.
- TypeORM не отметит миграцию применённой, если она не завершилась успешно.

## Альтернатива: отдельная ручная команда (если не хочется запускать на каждом старте)

Если по каким-то причинам ты не хочешь запускать миграции при каждом деплое, можно оставаться на ручном запуске:

```bash
railway exec npm --prefix backend run migration:run
```

Но это не решает задачу “без рук” — поэтому для CI/CD лучше вариант со стартовым скриптом.
