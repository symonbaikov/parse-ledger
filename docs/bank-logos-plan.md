# План: подтягивать реальный логотип банка при парсинге выписок

Цель: вместо кругляша с первой буквой названия банка показывать реальный логотип банка (и использовать букву как fallback, если логотип не найден/не загрузился).

## 1) Понять текущий флоу и точки интеграции

1. Зафиксировать, где именно во время парсинга появляется/вычисляется `bankName` (или аналог): на бэкенде при разборе выписки, либо позже при агрегации/нормализации.
2. Найти текущую модель/DTO, где хранится информация о банке (например: `institution`, `bank`, `merchant`, `account`), и где UI берет `name` для отображения.
3. Определить места, где сейчас строится “аватарка-буква”:
   - компонент на фронте (например, `Avatar` / `BankIcon` / список источников/хранилищ)
   - возможные места в SSR/CSR (Next.js app router)

Результат шага: список конкретных полей и файлов, которые нужно расширять (бэкенд DTO/сущности + фронтенд компонент отображения).

## 2) Выбрать источник логотипов (варианты и критерии)

Нужно выбрать один “источник правды” для получения логотипов по названию/идентификатору банка.

### Вариант A: свой каталог логотипов (рекомендуется для контроля)

- В репозитории хранить набор логотипов (SVG/PNG/WebP) + JSON-словарь соответствий.
- Плюсы: стабильность, независимость от внешних сервисов, предсказуемая лицензия/качество.
- Минусы: нужно вручную пополнять и поддерживать.

### Вариант B: внешний провайдер/каталог (если есть надежный источник)

- Подтягивать логотипы с внешнего API или CDN.
- Плюсы: меньше ручной поддержки.
- Минусы: доступность, лимиты, лицензии, риск изменений/удалений, нужна стратегия кэширования.

### Критерии выбора

- Лицензия на использование логотипов (юридически важно).
- Стабильность идентификаторов (по чему маппим: BIC, BIN, домен, официальное имя?).
- Качество (желательно SVG) и требования к размеру/прозрачности.
- Производительность: лишние запросы, кэш, дедупликация.

Рекомендуемое решение по умолчанию: **Вариант A** + опциональная возможность подключить внешний источник позже.

## 3) Спроектировать идентификацию банка (ключи маппинга)

Главная проблема: “Kaspi” может называться по-разному в выписках/эквайринге/локализации. Поэтому нужен нормализованный ключ.

### 3.1 Нормализация имени

- Привести строку к lower-case.
- Удалить организационно-правовые формы и шум: `АО`, `ОАО`, `JSC`, `LLC`, `bank`, `банк`, и т.п.
- Удалить лишние пробелы/пунктуацию.
- Поддержать альтернативные написания: транслитерация/кириллица/латиница (по необходимости).

### 3.2 Приоритетные “сильные” идентификаторы (если доступны)

Если в данных парсинга можно извлечь:
- BIC/SWIFT (идеально)
- BIN (для карточных операций)
- домен/issuer/эквайер

то маппинг должен сначала искать по ним, а уже потом по “имени”.

Результат шага: функция `normalizeBankKey(input) -> bankKey` и список источников данных для формирования ключа.

## 4) Модель данных: где хранить ссылку на логотип

### Опция 1: хранить `bankKey` в БД и рендерить логотип по ключу

- В транзакции/источнике/хранилище хранить `bankKey`.
- На фронте по `bankKey` вычислять URL логотипа (локально/через CDN).
- Плюсы: минимальные изменения данных, легкая смена логотипов без миграций.
- Минусы: фронт должен знать про правила резолва.

### Опция 2: хранить `logoUrl` (или `logoAssetId`) в БД

- На бэкенде резолвить логотип и отдавать готовый URL.
- Плюсы: фронт проще, единая логика.
- Минусы: миграции/обновления, нужно следить за актуальностью.

Рекомендуемое: **Опция 1** (хранить `bankKey`) + бэкенд отдает `bankKey` и (опционально) `logoUrl` как convenience-поле.

## 5) Каталог логотипов и маппинг

### 5.1 Структура ассетов

- `frontend/public/banks/<bankKey>.svg` (или `.webp`)
- единый размер/вьюбокс, прозрачный фон
- соглашение о названии: `kaspi.svg`, `halyk.svg`, `sber.svg`, и т.д.

### 5.2 Словарь соответствий

- `banks.json` (в общем пакете, доступном бэкенду и фронту) или отдельно:
  - `bankKey -> displayName`
  - `aliases -> bankKey` (варианты написаний)
  - (опционально) `bic -> bankKey`, `bin -> bankKey`

Важное: **не привязываться к “человеческому” имени как к ключу**, всегда резолвить в `bankKey`.

## 6) Изменения в парсинге (бэкенд)

1. На этапе парсинга выписки определить `rawBankName` / идентификаторы.
2. Прогнать через `resolveBankKey(rawBankName, bic?, bin?, swift?)`.
3. Сохранить `bankKey` в соответствующую сущность (где сейчас хранится банк/источник).
4. Отдавать в API:
   - `bankKey`
   - `bankName` (как display/оригинал)
   - (опционально) `bankLogoUrl` (если хотите централизовать)

## 7) Отображение на фронтенде (Next.js)

1. В UI заменить “букву” на компонент, который:
   - если есть `bankKey` → рендерит `<img src="/banks/<bankKey>.svg" ... />`
   - если нет или `onError` → рендерит текущий fallback (круг с буквой)
2. Добавить предзагрузку/оптимизацию:
   - использовать `next/image` (если подходит) или обычный `img` для SVG из `public`
   - единые размеры (например 32x32), `alt` = `bankName`
3. Учесть темную тему (если есть): предпочтительно использовать монохромные SVG или две версии (light/dark) по необходимости.

## 8) Кэширование и производительность

- Для локальных ассетов из `public/` проблем обычно нет.
- Если внешний источник:
  - проксировать через бэкенд (чтобы контролировать кеш/заголовки)
  - хранить в S3/Blob и отдавать через CDN
  - выставить `Cache-Control` (например, `public, max-age=31536000, immutable`) для версионированных путей

## 9) Деградация и UX-поведение

- Если логотип не найден:
  - показывать букву (текущая логика)
  - (опционально) показывать дефолтный “банк” икон (без бренда)
- Если найден, но загрузка упала:
  - `onError` → fallback на букву
- Если банк не распознан при парсинге:
  - `bankKey = null`, сохранить `rawBankName` для аналитики/дообучения словаря

## 10) Тесты и контроль качества

- Юнит-тесты для `normalizeBankKey/resolveBankKey` (кейсы с разными написаниями).
- Интеграционный тест парсера (на 2–3 реальных примерах выписок) на присвоение `bankKey`.
- UI-тест/скриншоты (минимум: проверка, что при отсутствии файла логотипа срабатывает fallback).

## 11) План внедрения (итерации)

1. Итерация 1: локальный каталог логотипов + `bankKey` + фронтовый компонент с fallback.
2. Итерация 2: расширение словаря алиасов + сбор статистики “не распознано”.
3. Итерация 3: (опционально) внешний источник + прокси/кэш + юридическое согласование.

## 12) Открытые вопросы (нужно ответить до реализации)

1. В каких странах/банках фокус (KZ/РФ/и т.д.)?
2. Какие форматы выписок поддерживаются и что из них можно reliably извлечь (BIC/BIN/SWIFT)?
3. Где лучше держать словарь: только фронт, только бэк, или общий пакет/модуль?
4. Есть ли требования по лицензированию и хранению бренд-ассетов?

