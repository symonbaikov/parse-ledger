name: CD

"on":
  push:
    branches:
      - staging
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        default: staging
        type: choice
        options:
          - staging
          - production

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  policy-as-code:
    runs-on: ubuntu-latest
    steps:
      - name: Harden runner (audit egress)
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Conftest (docker-compose)
        run: |
          docker run --rm \
            -v "$GITHUB_WORKSPACE":/project \
            -w /project \
            openpolicyagent/conftest:v0.56.0 \
            test -p policy/docker-compose \
            docker-compose.yml docker-compose.dev.yml docker-compose.observability.yml

      - name: Conftest (GitHub workflows)
        run: |
          docker run --rm \
            -v "$GITHUB_WORKSPACE":/project \
            -w /project \
            openpolicyagent/conftest:v0.56.0 \
            test -p policy/github-actions \
            .github/workflows/*.yml

      - name: Conftest (Railway)
        run: |
          docker run --rm \
            -v "$GITHUB_WORKSPACE":/project \
            -w /project \
            openpolicyagent/conftest:v0.56.0 \
            test -p policy/railway \
            railway.json

  build-and-publish:
    name: Build & publish hardened image
    runs-on: ubuntu-latest
    needs: policy-as-code
    environment:
      name: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || (github.ref == 'refs/heads/staging' && 'staging' || 'production') }}
    permissions:
      contents: write
      packages: write
      id-token: write
      attestations: write
    outputs:
      target_env: ${{ steps.env.outputs.target_env }}
      primary_tag: ${{ steps.image.outputs.primary_tag }}
    steps:
      - name: Harden runner (audit egress)
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Derive target environment
        id: env
        run: |
          if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
            echo "target_env=${{ github.event.inputs.environment }}" >> "$GITHUB_OUTPUT"
          elif [[ "${GITHUB_REF}" == "refs/heads/staging" ]]; then
            echo "target_env=staging" >> "$GITHUB_OUTPUT"
          else
            echo "target_env=production" >> "$GITHUB_OUTPUT"
          fi

      - name: Wait for CI to succeed
        uses: actions/github-script@v7
        with:
          script: |
            const workflowId = 'ci.yml';
            const timeoutMinutes = 15;
            const pollIntervalMs = 20000;
            const deadline = Date.now() + timeoutMinutes * 60 * 1000;

            while (true) {
              const { data } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowId,
                head_sha: context.sha,
                per_page: 1,
              });

              const run = data.workflow_runs[0];

              if (!run) {
                core.info('No CI run found yet. Waiting...');
              } else if (run.status === 'completed') {
                if (run.conclusion === 'success') {
                  core.info('CI is green for this commit.');
                  return;
                }
                core.setFailed(`CI run completed with conclusion: ${run.conclusion}`);
                return;
              } else {
                core.info(`CI status: ${run.status}. Waiting for completion...`);
              }

              if (Date.now() > deadline) {
                core.setFailed('Timed out waiting for CI results for this commit.');
                return;
              }

              await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
            }

      - name: Prepare image tags
        id: image
        run: |
          IMAGE_NAME=$(echo "ghcr.io/${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          TAGS="${IMAGE_NAME}:sha-${GITHUB_SHA::7}"
          PRIMARY_TAG="${IMAGE_NAME}:sha-${GITHUB_SHA::7}"

          if [[ "${GITHUB_REF}" == "refs/heads/staging" ]]; then
            TAGS="${TAGS}\n${IMAGE_NAME}:staging\n${IMAGE_NAME}:staging-${GITHUB_SHA::7}"
            PRIMARY_TAG="${IMAGE_NAME}:staging-${GITHUB_SHA::7}"
          elif [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            REF_NAME="${GITHUB_REF#refs/tags/}"
            TAGS="${TAGS}\n${IMAGE_NAME}:${REF_NAME}\n${IMAGE_NAME}:latest"
            PRIMARY_TAG="${IMAGE_NAME}:${REF_NAME}"
          elif [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" && "${{ github.event.inputs.environment }}" == "staging" ]]; then
            TAGS="${TAGS}\n${IMAGE_NAME}:staging\n${IMAGE_NAME}:staging-${GITHUB_SHA::7}"
            PRIMARY_TAG="${IMAGE_NAME}:staging-${GITHUB_SHA::7}"
          fi

          echo "image_name=${IMAGE_NAME}" >> "$GITHUB_OUTPUT"
          echo "primary_tag=${PRIMARY_TAG}" >> "$GITHUB_OUTPUT"
          echo "tags<<'EOF'" >> "$GITHUB_OUTPUT"
          echo "$TAGS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Set up QEMU (multi-arch)
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.image.outputs.tags }}
          platforms: linux/amd64,linux/arm64
          provenance: true

      - name: SLSA provenance attestation
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ steps.image.outputs.image_name }}
          subject-digest: ${{ steps.build.outputs.digest }}
          push-to-registry: true

      - name: Scan pushed image
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: ${{ steps.image.outputs.primary_tag }}
          severity: HIGH,CRITICAL
          vuln-type: "os,library"
          exit-code: 1
          hide-progress: true

      - name: Generate SBOM
        id: sbom
        uses: anchore/syft-action@v0.15.0
        with:
          image: ${{ steps.image.outputs.primary_tag }}
          output: sbom-${{ steps.env.outputs.target_env }}.spdx.json

      - name: SLSA SBOM attestation
        uses: actions/attest-sbom@v1
        with:
          subject-name: ${{ steps.image.outputs.image_name }}
          subject-digest: ${{ steps.build.outputs.digest }}
          sbom-path: sbom-${{ steps.env.outputs.target_env }}.spdx.json
          push-to-registry: true

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ steps.env.outputs.target_env }}
          path: sbom-${{ steps.env.outputs.target_env }}.spdx.json

      - name: Install cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign container image
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: cosign sign --yes --recursive ${{ steps.image.outputs.primary_tag }}

      - name: Attest SBOM
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: cosign attest --yes --predicate sbom-${{ steps.env.outputs.target_env }}.spdx.json --type spdxjson ${{ steps.image.outputs.primary_tag }}

      - name: Publish GitHub release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          files: sbom-${{ steps.env.outputs.target_env }}.spdx.json
          generate_release_notes: true

  smoke:
    name: Post-deploy smoke check
    runs-on: ubuntu-latest
    needs: build-and-publish
    if: needs.build-and-publish.outputs.target_env == 'staging' || needs.build-and-publish.outputs.target_env == 'production'
    permissions:
      id-token: write
    environment:
      name: ${{ needs.build-and-publish.outputs.target_env == 'production' && 'production' || 'staging' }}
    steps:
      - name: Harden runner (audit egress)
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit

      - name: Import smoke URL from Vault (OIDC, optional)
        if: ${{ secrets.VAULT_URL != '' && secrets.VAULT_JWT_ROLE != '' }}
        uses: hashicorp/vault-action@v3.0.0
        with:
          url: ${{ secrets.VAULT_URL }}
          caCertificate: ${{ secrets.VAULT_CA_CERT }}
          method: jwt
          role: ${{ secrets.VAULT_JWT_ROLE }}
          jwtGithubAudience: sigstore
          secrets: |
            secret/data/finflow/${{ needs.build-and-publish.outputs.target_env }} healthcheck_url | SMOKE_URL ;

      - name: Run smoke check
        env:
          SMOKE_URL: >-
            ${{ env.SMOKE_URL != '' && env.SMOKE_URL ||
            (needs.build-and-publish.outputs.target_env == 'production' && secrets.PROD_HEALTHCHECK_URL || secrets.STAGING_HEALTHCHECK_URL) }}
        run: |
          if [ -z "$SMOKE_URL" ]; then
            echo "No smoke URL configured; skipping smoke verification."
            exit 0
          fi

          echo "Hitting $SMOKE_URL..."
          for attempt in $(seq 1 10); do
            if curl -fsS "$SMOKE_URL"; then
              echo "Smoke check passed"
              exit 0
            fi
            echo "Attempt ${attempt}/10 failed, retrying..."
            sleep 6
          done

          echo "Smoke check failed after retries"
          exit 1
